package tcitoprommetrics

import (
	"encoding/json"

	"github.com/project-flogo/core/data/coerce"
)

// Settings for the activity
type Settings struct {
}

// Input for the activity
type Input struct {
	Metrics []AutoGenerated `md:"appMetrics"`
}

type AutoGenerated struct {
	App                App                  `md:"app"`
	AppInstanceMetrics []AppInstanceMetrics `md:"appInstanceMetrics"`
	AppMetrics         []AppMetrics         `md:"appMetrics"`
}
type App struct {
	AppID                string `md:"appId"`
	AppName              string `md:"appName"`
	AppType              string `md:"appType"`
	Category             string `md:"category"`
	CreatedTime          int    `md:"createdTime"`
	DeploymentStage      string `md:"deploymentStage"`
	DeploymentType       string `md:"deploymentType"`
	DesiredInstanceCount int    `md:"desiredInstanceCount"`
	EndpointVisibility   string `md:"endpointVisibility"`
	LastStartedTime      int64  `md:"lastStartedTime"`
	ModifiedTime         int64  `md:"modifiedTime"`
}

type Activities struct {
	ActivityName   string `md:"activityName"`
	AvgElapsedTime int    `md:"avgElapsedTime"`
	AvgExecTime    int    `md:"avgExecTime"`
	Completed      int    `md:"completed"`
	Failed         int    `md:"failed"`
	FlowName       string `md:"flowName"`
	MaxElapsedTime int    `md:"maxElapsedTime"`
	MaxExecTime    int    `md:"maxExecTime"`
	MinElapsedTime int    `md:"minElapsedTime"`
	MinExecTime    int    `md:"minExecTime"`
}

type Flows struct {
	AvgExecTime float64 `md:"avgExecTime"`
	Completed   int     `md:"completed"`
	Failed      int     `md:"failed"`
	FlowName    string  `md:"flowName"`
	MaxExecTime float64 `md:"maxExecTime"`
	MinExecTime float64 `md:"minExecTime"`
	Started     int     `md:"started"`
}
type Config struct {
	Interval     string `md:"interval"`
	IntervalUnit string `md:"interval_unit"`
	Repeating    string `md:"repeating"`
}

type Triggers struct {
	Completed   int    `md:"completed"`
	Failed      int    `md:"failed"`
	Started     int    `md:"started"`
	Status      string `md:"status"`
	TriggerName string `md:"trigger_name"`
}
type AppInstanceMetricsIn struct {
	AppName    string       `md:"app_name"`
	AppVersion string       `md:"app_version"`
	Flows      []Flows      `md:"flows"`
	Activities []Activities `md:"activities"`
	Triggers   []Triggers   `md:"triggers"`
}
type AppInstanceMetrics struct {
	AppInstance        string               `md:"appInstance"`
	AppInstanceMetrics AppInstanceMetricsIn `md:"appInstanceMetrics"`
}
type Labels struct {
	Status string `md:"status"`
}
type TciAppExecutions struct {
	Labels Labels `md:"labels,omitempty"`
	Value  int    `md:"value,omitempty"`
}
type TciAppInstancesCPU struct {
	Labels Labels  `md:"labels,omitempty"`
	Value  float64 `md:"value,omitempty"`
}
type TciAppInstancesMemory struct {
	Labels Labels  `md:"labels,omitempty"`
	Value  float64 `md:"value,omitempty"`
}
type TciAppSinceLastExecution struct {
	Value float64 `md:"value"`
}
type AppMetrics struct {
	InstanceId               string                     `md:"instanceId"`
	TciAppExecutions         []TciAppExecutions         `md:"tciAppExecutions"`
	TciAppInstancesCPU       []TciAppInstancesCPU       `md:"tciAppInstancesCpu"`
	TciAppInstancesMemory    []TciAppInstancesMemory    `md:"tciAppInstancesMemory"`
	TciAppSinceLastExecution []TciAppSinceLastExecution `md:"tciAppSinceLastExecution"`
}

type Sample struct {
	Labels map[string]string
	Value  float64
}

type MetricType struct {
	Name        string
	Description string
	Type        string
	Samples     []Sample
}

type MetricList struct {
	Metrics []*MetricType
}

func (r *MetricList) Create(name string, description string, metrictype string) *MetricType {
	metric := r.Get(name)
	if metric == nil {
		m := MetricType{Name: name, Description: description, Type: metrictype}
		r.Metrics = append(r.Metrics, &m)
		return &m
	}
	return metric
}

func (r MetricList) Get(name string) *MetricType {
	for _, metric := range r.Metrics {
		if metric.Name == name {
			return metric
		}
	}
	return nil
}

func (r *MetricType) Add(labels map[string]string, value float64) bool {
	s := Sample{labels, value}
	r.Samples = append(r.Samples, s)
	return true
}

// ToMap for Input
func (i *Input) ToMap() map[string]interface{} {
	return map[string]interface{}{
		"appMetrics": i.Metrics,
	}
}

// FromMap for input
func (i *Input) FromMap(values map[string]interface{}) error {
	kkk, _ := json.Marshal(values["appMetrics"])
	newValue := []AutoGenerated{}
	json.Unmarshal(kkk, &newValue)
	i.Metrics = newValue
	return nil
}

// Output for the activity
type Output struct {
	Data string `md:"data"`
}

// ToMap conver to object
func (o *Output) ToMap() map[string]interface{} {
	return map[string]interface{}{
		"data": o.Data,
	}
}

// FromMap convert to object
func (o *Output) FromMap(values map[string]interface{}) error {
	var err error
	o.Data, err = coerce.ToString(values["data"])
	if err != nil {
		return err
	}

	return nil
}
